

--- File: .babelrc ---
(Skipped (non-matching extension))


--- File: .eslintrc.json ---

{
  "ignorePatterns": ["cdk.out/", "coverage/", "lib/**/*.js", "bin/*.js"],
  "env": {
    "browser": false,
    "es2021": true,
    "node": true
  },
  "extends": ["airbnb-base", "prettier"],
  "plugins": ["prettier"],
  "parserOptions": {
    "ecmaVersion": "latest",
    "sourceType": "module"
  },
  "rules": {
    "prettier/prettier": "error",
    "import/prefer-default-export": "off",
    "no-await-in-loop": "off"
  },
  "overrides": [
    {
      "files": ["test/**"],
      "plugins": ["jest"],
      "extends": ["plugin:jest/recommended"],
      "rules": {
        "import/no-extraneous-dependencies": ["error", { "devDependencies": true }]
      }
    },
    {
      "files": ["lib/**"],
      "rules": {
        "import/no-extraneous-dependencies": ["error", { "devDependencies": false }]
      }
    }
  ]
}



--- File: .git ---
(Excluded)


--- File: .gitignore ---
(Excluded)


--- File: .npmignore ---
(Skipped (non-matching extension))


--- File: .prettierrc.json ---

{
  "trailingComma": "es5",
  "tabWidth": 2,
  "semi": false,
  "singleQuote": true,
  "printWidth": 120
}



--- File: README.md ---
(Skipped (non-matching extension))


--- File: dist ---
(Excluded)


--- File: jest.config.mjs ---
(Skipped (non-matching extension))


--- File: node_modules ---
(Excluded)


--- File: output.sick ---
(Skipped (non-matching extension))


--- File: package-lock.json ---
(Excluded)


--- File: package.json ---
(Excluded)


--- File: src/crypto/aes.ts ---

// aes.ts
import { initializeCrypto } from './init'
import { arrayToBase64, base64ToArray } from '../utils'
import { Base64String, AESEncryptResult } from './types'
import { sleep } from '../utils'

export const AESMakeKey = async (exportable: boolean = true): Promise<Base64String | CryptoKey> => {
  await sleep(0)

  const { crypto } = await initializeCrypto()

  const key = await crypto.subtle.generateKey({ name: 'AES-GCM', length: 256 }, exportable, ['encrypt', 'decrypt'])

  if (!exportable) {
    return key
  }

  const out = await crypto.subtle.exportKey('raw', key)
  return arrayToBase64(new Uint8Array(out))
}

export const AESImportKey = async (
  aes_key: Base64String | CryptoKey,
  exportable: boolean = true
): Promise<CryptoKey> => {
  await sleep(0)

  const { crypto, CryptoKey } = await initializeCrypto()

  // Type guard for CryptoKey
  const isCryptoKey = (key: Base64String | CryptoKey): key is CryptoKey => {
    return typeof key === 'object' && key !== null && 'type' in key && 'algorithm' in key
  }

  if (isCryptoKey(aes_key)) {
    return aes_key
  }

  return await crypto.subtle.importKey('raw', base64ToArray(aes_key).buffer, 'AES-GCM', exportable, [
    'encrypt',
    'decrypt',
  ])
}

export const AESEncrypt = async (
  base_64_key: Base64String | CryptoKey,
  base_64_data: Base64String,
  base_64_nonce: Base64String | false = false
): Promise<AESEncryptResult> => {
  await sleep(0)

  const { crypto } = await initializeCrypto()
  const aes_key = await AESImportKey(base_64_key)
  const nonce = base_64_nonce ? base64ToArray(base_64_nonce) : crypto.getRandomValues(new Uint8Array(16))

  const encrypted = await crypto.subtle.encrypt({ name: 'AES-GCM', iv: nonce }, aes_key, base64ToArray(base_64_data))

  return {
    ciphertext: arrayToBase64(new Uint8Array(encrypted)),
    iv: arrayToBase64(nonce),
  }
}

export const AESDecrypt = async (
  base_64_key: Base64String | CryptoKey,
  base_64_nonce: Base64String,
  base_64_cipher: Base64String,
  returnText: boolean = false
): Promise<string | ArrayBuffer> => {
  await sleep(0)

  const { crypto } = await initializeCrypto()
  const aes_key = await AESImportKey(base_64_key)
  const nonce_ary = base64ToArray(base_64_nonce)
  const cipher_ary = base64ToArray(base_64_cipher)

  const decrypted = await crypto.subtle.decrypt({ name: 'AES-GCM', iv: nonce_ary }, aes_key, cipher_ary)

  if (!returnText) {
    return decrypted
  }

  const decryptedArray = new Uint8Array(decrypted)
  return new TextDecoder().decode(decryptedArray)
}



--- File: src/crypto/ec-signature.ts ---

import type { Base64String, ECSignatureKeyPair } from './types'

import { EcdsaConvertKey } from './key-conversion'
import { sleep, arrayToBase64, base64ToArray } from '../utils'
import { initializeCrypto } from './init'

export const EcMakeSigKeys = async (exportable: boolean = true): Promise<ECSignatureKeyPair> => {
  await sleep(0)

  const { crypto } = await initializeCrypto()

  const keys = await crypto.subtle.generateKey({ name: 'ECDSA', namedCurve: 'P-256' }, exportable, ['sign', 'verify'])

  if (exportable) {
    const b64Keys = await Promise.all([
      crypto.subtle.exportKey('spki', keys.publicKey).then((key) => arrayToBase64(new Uint8Array(key))),
      crypto.subtle.exportKey('pkcs8', keys.privateKey).then((key) => arrayToBase64(new Uint8Array(key))),
    ])

    return { publicKey: b64Keys[0], privateKey: b64Keys[1] }
  }

  const b64Keys = await Promise.all([
    crypto.subtle.exportKey('spki', keys.publicKey).then((key) => arrayToBase64(new Uint8Array(key))),
  ])

  return { publicKey: b64Keys[0], privateKey: keys.privateKey }
}

export const EcSignData = async (
  b64PrivateKey: Base64String | CryptoKey,
  b64data: Base64String
): Promise<Base64String> => {
  await sleep(0)

  const privateKey = await EcdsaConvertKey(b64PrivateKey)
  const signature = await crypto.subtle.sign(
    { name: 'ECDSA', hash: { name: 'SHA-256' } },
    privateKey,
    base64ToArray(b64data)
  )

  return arrayToBase64(new Uint8Array(signature))
}

export const EcVerifySig = async (
  b64PublicKey: Base64String | CryptoKey,
  b64Signature: Base64String,
  b64data: Base64String
): Promise<boolean> => {
  await sleep(0)

  const publicKey = await EcdsaConvertKey(b64PublicKey)
  const signature = base64ToArray(b64Signature)

  return await crypto.subtle.verify(
    { name: 'ECDSA', hash: { name: 'SHA-256' } },
    publicKey,
    signature,
    base64ToArray(b64data)
  )
}



--- File: src/crypto/ec.ts ---

import type { Base64String, ECKeyPair, AESEncryptResult } from './types'

import { arrayToBase64, base64ToArray, sleep } from '../utils'
import { initializeCrypto } from './init'
import { AESEncrypt } from './aes'

import { EcdhConvertKey } from './key-conversion'

// ec.ts
export const EcMakeCryptKeys = async (exportable: boolean = true): Promise<ECKeyPair> => {
  await sleep(0)

  const { crypto } = await initializeCrypto()

  const keys = await crypto.subtle.generateKey({ name: 'ECDH', namedCurve: 'P-256' }, exportable, [
    'deriveKey',
    'deriveBits',
  ])

  if (!exportable) {
    const exportKeys = await Promise.all([
      crypto.subtle.exportKey('spki', keys.publicKey).then((key) => arrayToBase64(new Uint8Array(key))),
      keys.privateKey,
      crypto.subtle.exportKey('raw', keys.publicKey).then((key) => arrayToBase64(new Uint8Array(key))),
      crypto.subtle.exportKey('raw', keys.publicKey).then((key) => arrayToBase64(new Uint8Array(key).slice(1, 1000))),
    ])

    return {
      publicKey: exportKeys[0],
      privateKey: exportKeys[1],
      rawPublicKey: exportKeys[2],
      rawPublicKeyLite: exportKeys[3],
    }
  }

  const exportKeys = await Promise.all([
    crypto.subtle.exportKey('spki', keys.publicKey).then((key) => arrayToBase64(new Uint8Array(key))),
    crypto.subtle.exportKey('pkcs8', keys.privateKey).then((key) => arrayToBase64(new Uint8Array(key))),
    crypto.subtle.exportKey('jwk', keys.publicKey),
    crypto.subtle.exportKey('jwk', keys.privateKey),
    crypto.subtle.exportKey('raw', keys.publicKey).then((key) => arrayToBase64(new Uint8Array(key))),
    crypto.subtle.exportKey('raw', keys.publicKey).then((key) => arrayToBase64(new Uint8Array(key).slice(1, 1000))),
  ])

  return {
    publicKey: exportKeys[0],
    privateKey: exportKeys[1],
    jwkPublicKey: exportKeys[2],
    jwkPrivateKey: exportKeys[3],
    rawPublicKey: exportKeys[4],
    rawPublicKeyLite: exportKeys[5],
  }
}

export const EcEncrypt = async (
  b64Private: Base64String | CryptoKey,
  b64Public: Base64String | CryptoKey,
  b64data: Base64String
): Promise<AESEncryptResult> => {
  await sleep(0)

  const { crypto } = await initializeCrypto()

  const publicKey = await EcdhConvertKey(b64Public)
  const privateKey = await EcdhConvertKey(b64Private)

  const aes_key = await crypto.subtle.deriveKey(
    { name: 'ECDH', public: publicKey },
    privateKey,
    { name: 'AES-GCM', length: 256 },
    false,
    ['encrypt', 'decrypt']
  )

  return await AESEncrypt(aes_key, b64data)
}

export const EcDecrypt = async (
  b64Private: Base64String | CryptoKey,
  b64Public: Base64String | CryptoKey,
  b64Nonce: Base64String,
  b64data: Base64String,
  returnText: boolean = false
): Promise<string | ArrayBuffer> => {
  const { crypto } = await initializeCrypto()

  const publicKey = await EcdhConvertKey(b64Public)
  const privateKey = await EcdhConvertKey(b64Private)
  const nonce = base64ToArray(b64Nonce)
  const data = base64ToArray(b64data)

  const aes_key = await crypto.subtle.deriveKey(
    { name: 'ECDH', public: publicKey },
    privateKey,
    { name: 'AES-GCM', length: 256 },
    false,
    ['encrypt', 'decrypt']
  )

  const decryptedData = await crypto.subtle.decrypt({ name: 'AES-GCM', iv: nonce }, aes_key, data)

  if (!returnText) {
    return decryptedData
  }

  const decrypted = new Uint8Array(decryptedData)
  return new TextDecoder().decode(decrypted)
}



--- File: src/crypto/hash.ts ---

// hash.ts
import { initializeCrypto } from './init'
import { arrayToBase64 } from '../utils'
import { HashAlgorithm, Base64String } from './types'

export const HASH = async (algo: HashAlgorithm, data: string, len?: number): Promise<Base64String> => {
  const { crypto } = await initializeCrypto()
  const hash = await crypto.subtle.digest(algo, new TextEncoder().encode(data))
  const ary = new Uint8Array(hash)

  if (!len) {
    return arrayToBase64(ary)
  }

  const outAry = new Uint8Array(len)
  const max = Math.max(len, ary.length)

  for (let i = 0; i < max; i++) {
    outAry[i % len] = outAry[i % len] ^ ary[i % ary.length]
  }

  return arrayToBase64(outAry)
}



--- File: src/crypto/hkdf.ts ---

import { initializeCrypto } from './init'
import { EcdhConvertKey } from './key-conversion'
import { sleep } from '../utils'
import { base64ToArray, arrayToBase64 } from '../utils'

import type { Base64String, HKDFEncryptResult } from './types'

export const HKDFEncrypt = async (
  b64Private: Base64String | CryptoKey,
  b64Public: Base64String | CryptoKey,
  b64data: Base64String
): Promise<HKDFEncryptResult> => {
  await sleep(0)

  const { crypto } = await initializeCrypto()

  // Convert keys
  const publicKey = await EcdhConvertKey(b64Public)
  const privateKey = await EcdhConvertKey(b64Private)

  // Generate shared secret for HKDF
  const sharedSecret = await crypto.subtle.deriveBits(
    {
      name: 'ECDH',
      public: publicKey,
    },
    privateKey,
    256
  )

  // Convert shared-secret into a key
  const sharedSecretKey = await crypto.subtle.importKey('raw', sharedSecret, { name: 'HKDF' }, false, [
    'deriveKey',
    'deriveBits',
  ])

  // Create SALT
  const salt = crypto.getRandomValues(new Uint8Array(16))

  // Convert the live-shared-secret-key into an aes key
  const derivedKey = await crypto.subtle.deriveBits(
    {
      name: 'HKDF',
      hash: 'SHA-256',
      salt: salt,
      info: new Uint8Array([]),
    },
    sharedSecretKey,
    256
  )

  // Convert the Key-Array to a live Key
  const aes_key = await crypto.subtle.importKey('raw', derivedKey, 'AES-GCM', false, ['encrypt', 'decrypt'])

  // Init Vector
  const iv = crypto.getRandomValues(new Uint8Array(16))

  // Encrypt
  const encrypted = await crypto.subtle.encrypt({ name: 'AES-GCM', iv: iv }, aes_key, base64ToArray(b64data))

  return {
    ciphertext: arrayToBase64(new Uint8Array(encrypted)),
    salt: arrayToBase64(salt),
    iv: arrayToBase64(iv),
  }
}

export const HKDFDecrypt = async (
  b64Private: Base64String | CryptoKey,
  b64Public: Base64String | CryptoKey,
  b64Salt: Base64String,
  b64iv: Base64String,
  b64data: Base64String,
  returnText: boolean = false
): Promise<string | ArrayBuffer> => {
  await sleep(0)

  const { crypto } = await initializeCrypto()

  const publicKey = await EcdhConvertKey(b64Public)
  const privateKey = await EcdhConvertKey(b64Private)
  const salt = base64ToArray(b64Salt)
  const iv = base64ToArray(b64iv)
  const data = base64ToArray(b64data)

  // Generate shared secret for HKDF
  const sharedSecret = await crypto.subtle.deriveBits(
    {
      name: 'ECDH',
      public: publicKey,
    },
    privateKey,
    256
  )

  // Convert shared-secret into a key
  const sharedSecretKey = await crypto.subtle.importKey('raw', sharedSecret, { name: 'HKDF' }, false, [
    'deriveKey',
    'deriveBits',
  ])

  // Convert the live-shared-secret-key into an aes key
  const derivedKey = await crypto.subtle.deriveBits(
    {
      name: 'HKDF',
      hash: 'SHA-256',
      salt: salt,
      info: new Uint8Array([]),
    },
    sharedSecretKey,
    256
  )

  // Convert the Key-Array to a live Key
  const aes_key = await crypto.subtle.importKey('raw', derivedKey, 'AES-GCM', false, ['encrypt', 'decrypt'])

  try {
    const aes_data = await crypto.subtle.decrypt({ name: 'AES-GCM', iv: iv }, aes_key, data)

    if (!returnText) {
      return aes_data
    }

    const decrypted = new Uint8Array(aes_data)
    return new TextDecoder().decode(decrypted)
  } catch (e: any) {
    console.log({ name: e.name, stack: e.stack, message: e.message })
    throw e
  }
}



--- File: src/crypto/hmac.ts ---

// hmac.ts
import { initializeCrypto } from './init'
import { HexString } from './types'

export const HMAC = async (secret: string, data: string): Promise<HexString> => {
  const { crypto } = await initializeCrypto()
  const encoder = new TextEncoder()
  const encodedSecret = encoder.encode(secret)
  const encodedData = encoder.encode(data)

  const key = await crypto.subtle.importKey('raw', encodedSecret, { name: 'HMAC', hash: { name: 'SHA-256' } }, false, [
    'sign',
    'verify',
  ])

  const sig = await crypto.subtle.sign('HMAC', key, encodedData)
  const b = new Uint8Array(sig)

  return Array.prototype.map.call(b, (x: number) => ('00' + x.toString(16)).slice(-2)).join('')
}



--- File: src/crypto/init.ts ---

import type { CryptoContext } from './types'
export const initializeCrypto = async (): Promise<CryptoContext> => {
  let cryptoAPI: CryptoContext

  if (typeof globalThis.crypto !== 'undefined') {
    cryptoAPI = {
      crypto: globalThis.crypto,
      CryptoKey: globalThis.CryptoKey || null,
    }
  } else if (typeof globalThis.require === 'function') {
    const { webcrypto } = await import('crypto')
    cryptoAPI = {
      crypto: webcrypto as Crypto,
      CryptoKey: null,
    }
  } else {
    throw new Error('Crypto API is not available in this environment')
  }

  return cryptoAPI
}



--- File: src/crypto/key-conversion.ts ---

import type { Base64String } from './types'
import { sleep } from '../utils'
import { initializeCrypto } from './init'
import { base64ToArray } from '../utils'

// key-conversion.ts
export const EcdhConvertKey = async (unknown_key: Base64String | CryptoKey): Promise<CryptoKey> => {
  await sleep(0)

  const { crypto, CryptoKey } = await initializeCrypto()

  // Type guard for CryptoKey
  if (CryptoKey && unknown_key instanceof CryptoKey) {
    return unknown_key
  }

  if (typeof unknown_key !== 'string') {
    throw new Error('Invalid key format')
  }

  try {
    // Try SPKI PUBLIC
    return await crypto.subtle.importKey(
      'spki',
      base64ToArray(unknown_key),
      { name: 'ECDH', namedCurve: 'P-256' },
      true,
      []
    )
  } catch (e) {}

  try {
    // Try RAW PUBLIC
    return await crypto.subtle.importKey(
      'raw',
      base64ToArray(unknown_key),
      { name: 'ECDH', namedCurve: 'P-256' },
      true,
      []
    )
  } catch (e) {}

  try {
    // Try PKCS8 PRIVATE
    return await crypto.subtle.importKey(
      'pkcs8',
      base64ToArray(unknown_key),
      { name: 'ECDH', namedCurve: 'P-256' },
      false,
      ['deriveKey', 'deriveBits']
    )
  } catch (e) {}

  try {
    // Try RAW PUBLIC - PERVERTED
    const longKey = new Uint8Array([4, ...Array.from(base64ToArray(unknown_key))])
    return await crypto.subtle.importKey('raw', longKey, { name: 'ECDH', namedCurve: 'P-256' }, true, [])
  } catch (e) {
    throw new Error('UNRECOGNIZED KEY FORMAT')
  }
}

export const EcdsaConvertKey = async (unknown_key: Base64String | CryptoKey): Promise<CryptoKey> => {
  await sleep(0)

  const { crypto, CryptoKey } = await initializeCrypto()

  // Type guard for CryptoKey
  if (CryptoKey && unknown_key instanceof CryptoKey) {
    return unknown_key
  }

  if (typeof unknown_key !== 'string') {
    throw new Error('Invalid key format')
  }

  try {
    // Try SPKI PUBLIC
    return await crypto.subtle.importKey(
      'spki',
      base64ToArray(unknown_key),
      { name: 'ECDSA', namedCurve: 'P-256' },
      true,
      ['verify']
    )
  } catch (e) {}

  try {
    // Try RAW PUBLIC
    return await crypto.subtle.importKey(
      'raw',
      base64ToArray(unknown_key),
      { name: 'ECDSA', namedCurve: 'P-256' },
      true,
      ['verify']
    )
  } catch (e) {}

  try {
    // Try PKCS8 PRIVATE
    return await crypto.subtle.importKey(
      'pkcs8',
      base64ToArray(unknown_key),
      { name: 'ECDSA', namedCurve: 'P-256' },
      false,
      ['sign']
    )
  } catch (e) {}

  try {
    // Try RAW PUBLIC - PERVERTED
    const longKey = new Uint8Array([4, ...Array.from(base64ToArray(unknown_key))])
    return await crypto.subtle.importKey('raw', longKey, { name: 'ECDSA', namedCurve: 'P-256' }, true, ['sign'])
  } catch (e) {
    throw new Error('UNRECOGNIZED KEY FORMAT')
  }
}



--- File: src/crypto/password.ts ---

import type { Base64String } from './types'
import { AESMakeKey, AESDecrypt, AESEncrypt, AESImportKey } from './aes'
import { HASH } from './hash'
import { sleep } from '../utils'
const iterations = 5_000

export const PASSWORD_ENCRYPT = async (password: string, base64data: Base64String): Promise<Base64String> => {
  await sleep(0)

  // 1. Strengthen the password through multiple rounds of hashing
  let strengthenedPassword = password
  for (let i = 0; i < iterations; i++) {
    strengthenedPassword = await HASH('SHA-512', strengthenedPassword)
  }

  // 2. Generate an AES key for the actual encryption
  const aes = (await AESMakeKey(true)) as Base64String

  // 3. Use the strengthened password as the IV for encryption
  const strengthenedPasswordHash = btoa(strengthenedPassword)

  // 4. Encrypt the data using the AES key and strengthened password as IV
  const output = await AESEncrypt(aes, base64data, strengthenedPasswordHash)

  // 5. Bundle everything needed for decryption
  return btoa(
    JSON.stringify({
      ciphertext: output.ciphertext,
      aes,
    })
  )
}

export const PASSWORD_DECRYPT = async (password: string, base64data: Base64String): Promise<string> => {
  await sleep(0)

  // 1. Strengthen the password the same way
  let strengthenedPassword = password
  for (let i = 0; i < iterations; i++) {
    strengthenedPassword = await HASH('SHA-512', strengthenedPassword)
  }

  // 2. Get the strengthened password hash
  const strengthenedPasswordHash = btoa(strengthenedPassword)

  // 3. Parse the encrypted data
  const encryptedDataObject = JSON.parse(atob(base64data))

  // 4. Import the AES key
  const aes = await AESImportKey(encryptedDataObject.aes, false)

  // 5. Decrypt using the same strengthened password as IV
  const plaintext = (await AESDecrypt(aes, strengthenedPasswordHash, encryptedDataObject.ciphertext, true)) as string

  return plaintext
}



--- File: src/crypto/types.ts ---

// types.ts
export type Base64String = string
export type HexString = string

export interface CryptoContext {
  crypto: Crypto
  CryptoKey: typeof CryptoKey | null
}

export interface AESEncryptResult {
  ciphertext: Base64String
  iv: Base64String
}

// Additional types needed for AES operations
export interface AESDecryptResult {
  data: ArrayBuffer
  text?: string
}

export interface PasswordEncryptResult {
  ciphertext: Base64String
  aes: Base64String
}

export interface ECKeyPairExportable {
  publicKey: Base64String
  privateKey: Base64String
  jwkPublicKey: JsonWebKey
  jwkPrivateKey: JsonWebKey
  rawPublicKey: Base64String
  rawPublicKeyLite: Base64String
}

export interface ECKeyPairNonExportable {
  publicKey: Base64String
  privateKey: CryptoKey
  rawPublicKey: Base64String
  rawPublicKeyLite: Base64String
}

export type ECKeyPair = ECKeyPairExportable | ECKeyPairNonExportable

export type HashAlgorithm = 'SHA-1' | 'SHA-256' | 'SHA-384' | 'SHA-512'

export interface HKDFEncryptResult {
  ciphertext: Base64String
  salt: Base64String
  iv: Base64String
}

export interface ECSignatureKeyPair {
  publicKey: Base64String
  privateKey: Base64String | CryptoKey
}



--- File: src/index.ts ---

export * from './crypto/types'
export * from './utils'
export * from './crypto/hmac'
export * from './crypto/hash'
export * from './crypto/aes'
export * from './crypto/password'
export * from './crypto/ec'
export * from './crypto/hkdf'
export * from './crypto/ec-signature'
export * from './crypto/key-conversion'



--- File: src/types/crypto/index.d.ts ---

// src/types/crypto/index.d.ts
declare module '@/types/crypto' {
  export type Base64String = string
  export type HexString = string

  export interface CryptoContext {
    crypto: Crypto
    CryptoKey: typeof CryptoKey | null
  }

  export interface AESEncryptResult {
    ciphertext: Base64String
    iv: Base64String
  }

  export interface PasswordEncryptResult {
    ciphertext: Base64String
    aes: Base64String
  }

  export interface ECKeyPairExportable {
    publicKey: Base64String
    privateKey: Base64String
    jwkPublicKey: JsonWebKey
    jwkPrivateKey: JsonWebKey
    rawPublicKey: Base64String
    rawPublicKeyLite: Base64String
  }

  export interface ECKeyPairNonExportable {
    publicKey: Base64String
    privateKey: CryptoKey
    rawPublicKey: Base64String
    rawPublicKeyLite: Base64String
  }

  export type ECKeyPair = ECKeyPairExportable | ECKeyPairNonExportable

  export type HashAlgorithm = 'SHA-1' | 'SHA-256' | 'SHA-384' | 'SHA-512'
}



--- File: src/types/index.d.ts ---




--- File: src/utils/index.ts ---

import type { Base64String } from '@/types/crypto'
export const base64ToArray = (strng: Base64String): Uint8Array => {
  return Uint8Array.from(atob(strng), (c) => c.charCodeAt(0))
}

export const arrayToBase64 = (utf8Bytes: Uint8Array): Base64String => {
  const chunkSize = 8192
  const chunks: string[] = []

  for (let i = 0; i < utf8Bytes.length; i += chunkSize) {
    const chunk = utf8Bytes.subarray(i, i + chunkSize)
    chunks.push(String.fromCharCode.apply(null, [...chunk]))
  }

  return btoa(chunks.join(''))
}

export const sleep = async (duration: number): Promise<void> => {
  await new Promise((resolve) => setTimeout(resolve, duration))
}



--- File: tsconfig.base.json ---

{
  "compilerOptions": {
    "target": "ES2020",
    "lib": ["es2020", "dom"],
    "declaration": true,
    "strict": true,
    "noImplicitAny": true,
    "strictNullChecks": true,
    "noImplicitThis": true,
    "alwaysStrict": true,
    "noUnusedLocals": false,
    "noUnusedParameters": false,
    "noImplicitReturns": true,
    "noFallthroughCasesInSwitch": false,
    "inlineSourceMap": true,
    "inlineSources": true,
    "experimentalDecorators": true,
    "strictPropertyInitialization": false,
    "typeRoots": ["./node_modules/@types"],
    "types": ["node"],
    "allowJs": true,
    "esModuleInterop": true,
    "moduleResolution": "node",
    "rootDir": "src"
  },
  "include": ["src/**/*"],
  "exclude": ["node_modules", "cdk.out"]
}


--- File: tsconfig.cjs.json ---

{
  "extends": "./tsconfig.base.json",
  "compilerOptions": {
    "module": "CommonJS",
    "outDir": "dist/cjs"
  }
}


--- File: tsconfig.esm.json ---

{
  "extends": "./tsconfig.base.json",
  "compilerOptions": {
    "module": "ES2020",
    "outDir": "dist/esm"
  }
}
