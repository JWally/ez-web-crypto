

--- File: .git/HEAD ---
(Skipped (non-matching extension))


--- File: .git/ORIG_HEAD ---
(Skipped (non-matching extension))


--- File: .git/config ---
(Skipped (non-matching extension))


--- File: .git/description ---
(Skipped (non-matching extension))


--- File: .git/hooks/applypatch-msg.sample ---
(Skipped (non-matching extension))


--- File: .git/hooks/commit-msg.sample ---
(Skipped (non-matching extension))


--- File: .git/hooks/fsmonitor-watchman.sample ---
(Skipped (non-matching extension))


--- File: .git/hooks/post-update.sample ---
(Skipped (non-matching extension))


--- File: .git/hooks/pre-applypatch.sample ---
(Skipped (non-matching extension))


--- File: .git/hooks/pre-commit.sample ---
(Skipped (non-matching extension))


--- File: .git/hooks/pre-merge-commit.sample ---
(Skipped (non-matching extension))


--- File: .git/hooks/pre-push.sample ---
(Skipped (non-matching extension))


--- File: .git/hooks/pre-rebase.sample ---
(Skipped (non-matching extension))


--- File: .git/hooks/pre-receive.sample ---
(Skipped (non-matching extension))


--- File: .git/hooks/prepare-commit-msg.sample ---
(Skipped (non-matching extension))


--- File: .git/hooks/push-to-checkout.sample ---
(Skipped (non-matching extension))


--- File: .git/hooks/sendemail-validate.sample ---
(Skipped (non-matching extension))


--- File: .git/hooks/update.sample ---
(Skipped (non-matching extension))


--- File: .git/index ---
(Skipped (non-matching extension))


--- File: .git/info/exclude ---
(Skipped (non-matching extension))


--- File: .git/logs/HEAD ---
(Skipped (non-matching extension))


--- File: .git/logs/refs/heads/main ---
(Skipped (non-matching extension))


--- File: .git/logs/refs/heads/modularization ---
(Skipped (non-matching extension))


--- File: .git/logs/refs/remotes/origin/HEAD ---
(Skipped (non-matching extension))


--- File: .git/objects/pack/pack-a8b1011eceeafccbcc10c03a197d3a3b0904402b.idx ---
(Skipped (non-matching extension))


--- File: .git/objects/pack/pack-a8b1011eceeafccbcc10c03a197d3a3b0904402b.pack ---
(Skipped (non-matching extension))


--- File: .git/objects/pack/pack-a8b1011eceeafccbcc10c03a197d3a3b0904402b.rev ---
(Skipped (non-matching extension))


--- File: .git/packed-refs ---
(Skipped (non-matching extension))


--- File: .git/refs/heads/main ---
(Skipped (non-matching extension))


--- File: .git/refs/heads/modularization ---
(Skipped (non-matching extension))


--- File: .git/refs/remotes/origin/HEAD ---
(Skipped (non-matching extension))


--- File: .gitignore ---
(Skipped (non-matching extension))


--- File: .npmignore ---
(Skipped (non-matching extension))


--- File: README.md ---
(Skipped (non-matching extension))


--- File: coverage ---
(Excluded)


--- File: index.d.ts ---

declare module "@justinwwolcott/ez-web-crypto" {
    export default class EZ_WEB_CRYPTO {
      private nodeEnvLoad: () => Promise<void>;
      private sleep: (duration: number) => Promise<void>;
      constructor();
      base64ToArray(strng: string): Uint8Array;
      arrayToBase64(ary: Uint8Array): string;
      HMAC(secret: string, data: string): Promise<string>;
      HASH(algo: string, data: string, len?: number): Promise<string>;
      PASSWORD_ENCRYPT(password: string, base64data: string): Promise<string>;
      PASSWORD_DECRYPT(password: string, base64data: string): Promise<string>;
      AESMakeKey(exportable?: boolean): Promise<string | CryptoKey>;
      AESImportKey(aes_key: string | CryptoKey, exportable?: boolean): Promise<CryptoKey>;
      AESEncrypt(
        base_64_key: string | CryptoKey,
        base_64_data: string,
        base_64_nonce?: boolean
      ): Promise<{ ciphertext: string; iv: string }>;
      AESDecrypt(
        base_64_key: string | CryptoKey,
        base_64_nonce: string,
        base_64_cipher: string,
        returnText?: boolean
      ): Promise<ArrayBuffer | string>;
      EcMakeCryptKeys(exportable?: boolean): Promise<any>;
      EcEncrypt(
        b64Private: string,
        b64Public: string,
        b64data: string
      ): Promise<{ ciphertext: string; iv: string }>;
      EcDecrypt(
        b64Private: string,
        b64Public: string,
        b64Nonce: string,
        b64data: string
      ): Promise<ArrayBuffer>;
      HKDFEncrypt(
        b64Private: string,
        b64Public: string,
        b64data: string
      ): Promise<{ ciphertext: string; salt: string; iv: string }>;
      HKDFDecrypt(
        b64Private: string,
        b64Public: string,
        b64Salt: string,
        b64iv: string,
        b64data: string
      ): Promise<ArrayBuffer>;
      EcMakeSigKeys(exportable?: boolean): Promise<{ publicKey: string; privateKey: string | CryptoKey }>;
      EcSignData(b64PrivateKey: string, b64data: string): Promise<string>;
      EcVerifySig(
        b64PublicKey: string,
        b64Signature: string,
        b64data: string
      ): Promise<boolean>;
      EcdhConvertKey(unknown_key: any): Promise<CryptoKey>;
      EcdsaConvertKey(unknown_key: any): Promise<CryptoKey>;
    }
  }
  


--- File: index.js ---
(Skipped (non-matching extension))


--- File: jest.config.js ---
(Skipped (non-matching extension))


--- File: node_modules ---
(Excluded)


--- File: output.sick ---
(Skipped (non-matching extension))


--- File: package-lock.json ---
(Skipped (non-matching extension))


--- File: package.json ---
(Skipped (non-matching extension))


--- File: src/crypto/aes.ts ---

// aes.ts
import { initializeCrypto } from './init';
import { arrayToBase64, base64ToArray } from '../utils';
import { Base64String, AESEncryptResult } from './types';
import { sleep } from '../utils';


export const AESMakeKey = async (exportable: boolean = true): Promise<Base64String | CryptoKey> => {
  await sleep(0);

  const { crypto } = await initializeCrypto();
  
  const key = await crypto.subtle.generateKey(
    { name: "AES-GCM", length: 256 },
    exportable,
    ["encrypt", "decrypt"]
  );

  if (!exportable) {
    return key;
  }

  const out = await crypto.subtle.exportKey("raw", key);
  return arrayToBase64(new Uint8Array(out));
};

export const AESImportKey = async (
  aes_key: Base64String | CryptoKey,
  exportable: boolean = true
): Promise<CryptoKey> => {
  await sleep(0);
  
  const { crypto, CryptoKey } = await initializeCrypto();

  // Type guard for CryptoKey
  const isCryptoKey = (key: Base64String | CryptoKey): key is CryptoKey => {
    return typeof key === "object" && key !== null && "type" in key && "algorithm" in key;
  };

  if (isCryptoKey(aes_key)) {
    return aes_key;
  }

  return await crypto.subtle.importKey(
    "raw",
    base64ToArray(aes_key).buffer,
    "AES-GCM",
    exportable,
    ["encrypt", "decrypt"]
  );
};

export const AESEncrypt = async (
  base_64_key: Base64String | CryptoKey,
  base_64_data: Base64String,
  base_64_nonce: Base64String | false = false
): Promise<AESEncryptResult> => {
  await sleep(0);
  
  const { crypto } = await initializeCrypto();
  const aes_key = await AESImportKey(base_64_key);
  const nonce = base_64_nonce ? 
    base64ToArray(base_64_nonce) : 
    crypto.getRandomValues(new Uint8Array(16));

  const encrypted = await crypto.subtle.encrypt(
    { name: "AES-GCM", iv: nonce },
    aes_key,
    base64ToArray(base_64_data)
  );

  return {
    ciphertext: arrayToBase64(new Uint8Array(encrypted)),
    iv: arrayToBase64(nonce),
  };
};

export const AESDecrypt = async (
  base_64_key: Base64String | CryptoKey,
  base_64_nonce: Base64String,
  base_64_cipher: Base64String,
  returnText: boolean = false
): Promise<string | ArrayBuffer> => {
  await sleep(0);

  const { crypto } = await initializeCrypto();
  const aes_key = await AESImportKey(base_64_key);
  const nonce_ary = base64ToArray(base_64_nonce);
  const cipher_ary = base64ToArray(base_64_cipher);

  const decrypted = await crypto.subtle.decrypt(
    { name: "AES-GCM", iv: nonce_ary },
    aes_key,
    cipher_ary
  );

  if (!returnText) {
    return decrypted;
  }

  const decryptedArray = new Uint8Array(decrypted);
  return new TextDecoder().decode(decryptedArray);
};




--- File: src/crypto/ec-signature.ts ---

import type { Base64String, ECSignatureKeyPair} from "./types";

import { EcdsaConvertKey } from "./key-conversion";
import { sleep, arrayToBase64, base64ToArray } from "../utils";
import { initializeCrypto } from "./init";

export const EcMakeSigKeys = async (exportable: boolean = true): Promise<ECSignatureKeyPair> => {
    await sleep(0);
  
    const { crypto } = await initializeCrypto();
  
    const keys = await crypto.subtle.generateKey(
      { name: "ECDSA", namedCurve: "P-256" },
      exportable,
      ["sign", "verify"]
    );
  
    if (exportable) {
      const b64Keys = await Promise.all([
        crypto.subtle.exportKey("spki", keys.publicKey).then((key) => 
          arrayToBase64(new Uint8Array(key))),
        crypto.subtle.exportKey("pkcs8", keys.privateKey).then((key) => 
          arrayToBase64(new Uint8Array(key)))
      ]);
      
      return { publicKey: b64Keys[0], privateKey: b64Keys[1] };
    } 
      
    const b64Keys = await Promise.all([
      crypto.subtle.exportKey("spki", keys.publicKey).then((key) => 
        arrayToBase64(new Uint8Array(key)))
    ]);
  
    return { publicKey: b64Keys[0], privateKey: keys.privateKey };
  };
  
  export const EcSignData = async (
    b64PrivateKey: Base64String | CryptoKey,
    b64data: Base64String
  ): Promise<Base64String> => {
    await sleep(0);
  
    const privateKey = await EcdsaConvertKey(b64PrivateKey);
    const signature = await crypto.subtle.sign(
      { name: "ECDSA", hash: { name: "SHA-256" } },
      privateKey,
      base64ToArray(b64data)
    );
  
    return arrayToBase64(new Uint8Array(signature));
  };
  
  export const EcVerifySig = async (
    b64PublicKey: Base64String | CryptoKey,
    b64Signature: Base64String,
    b64data: Base64String
  ): Promise<boolean> => {
    await sleep(0);
  
    const publicKey = await EcdsaConvertKey(b64PublicKey);
    const signature = base64ToArray(b64Signature);
  
    return await crypto.subtle.verify(
      { name: "ECDSA", hash: { name: "SHA-256" } },
      publicKey,
      signature,
      base64ToArray(b64data)
    );
  };


--- File: src/crypto/ec.ts ---

import type { Base64String, ECKeyPair, AESEncryptResult } from "./types";

import { arrayToBase64, base64ToArray, sleep } from "../utils";
import { initializeCrypto } from "./init";
import { AESEncrypt } from "./aes";

import { EcdhConvertKey } from "./key-conversion";

// ec.ts
export const EcMakeCryptKeys = async (exportable: boolean = true): Promise<ECKeyPair> => {
    await sleep(0);
  
    const { crypto } = await initializeCrypto();
  
    const keys = await crypto.subtle.generateKey(
      { name: "ECDH", namedCurve: "P-256" },
      exportable,
      ["deriveKey", "deriveBits"]
    );
  
    if (!exportable) {
      const exportKeys = await Promise.all([
        crypto.subtle.exportKey("spki", keys.publicKey).then((key) => 
          arrayToBase64(new Uint8Array(key))),
        keys.privateKey,
        crypto.subtle.exportKey("raw", keys.publicKey).then((key) => 
          arrayToBase64(new Uint8Array(key))),
        crypto.subtle.exportKey("raw", keys.publicKey).then((key) => 
          arrayToBase64(new Uint8Array(key).slice(1, 1000)))
      ]);
  
      return {
        publicKey: exportKeys[0],
        privateKey: exportKeys[1],
        rawPublicKey: exportKeys[2],
        rawPublicKeyLite: exportKeys[3]
      };
    }
  
    const exportKeys = await Promise.all([
      crypto.subtle.exportKey("spki", keys.publicKey).then((key) => 
        arrayToBase64(new Uint8Array(key))),
      crypto.subtle.exportKey("pkcs8", keys.privateKey).then((key) => 
        arrayToBase64(new Uint8Array(key))),
      crypto.subtle.exportKey("jwk", keys.publicKey),
      crypto.subtle.exportKey("jwk", keys.privateKey),
      crypto.subtle.exportKey("raw", keys.publicKey).then((key) => 
        arrayToBase64(new Uint8Array(key))),
      crypto.subtle.exportKey("raw", keys.publicKey).then((key) => 
        arrayToBase64(new Uint8Array(key).slice(1, 1000)))
    ]);
  
    return {
      publicKey: exportKeys[0],
      privateKey: exportKeys[1],
      jwkPublicKey: exportKeys[2],
      jwkPrivateKey: exportKeys[3],
      rawPublicKey: exportKeys[4],
      rawPublicKeyLite: exportKeys[5]
    };
  };
  
  export const EcEncrypt = async (
    b64Private: Base64String | CryptoKey,
    b64Public: Base64String | CryptoKey,
    b64data: Base64String
  ): Promise<AESEncryptResult> => {
    await sleep(0);
  
    const { crypto } = await initializeCrypto();
    
    const publicKey = await EcdhConvertKey(b64Public);
    const privateKey = await EcdhConvertKey(b64Private);
    
    const aes_key = await crypto.subtle.deriveKey(
      { name: "ECDH", public: publicKey },
      privateKey,
      { name: "AES-GCM", length: 256 },
      false,
      ["encrypt", "decrypt"]
    );
    
    return await AESEncrypt(aes_key, b64data);
  };
  
  export const EcDecrypt = async (
    b64Private: Base64String | CryptoKey,
    b64Public: Base64String | CryptoKey,
    b64Nonce: Base64String,
    b64data: Base64String,
    returnText: boolean = false
  ): Promise<string | ArrayBuffer> => {
    const { crypto } = await initializeCrypto();
    
    const publicKey = await EcdhConvertKey(b64Public);
    const privateKey = await EcdhConvertKey(b64Private);
    const nonce = base64ToArray(b64Nonce);
    const data = base64ToArray(b64data);
  
    const aes_key = await crypto.subtle.deriveKey(
      { name: "ECDH", public: publicKey },
      privateKey,
      { name: "AES-GCM", length: 256 },
      false,
      ["encrypt", "decrypt"]
    );
  
    const decryptedData = await crypto.subtle.decrypt(
      { name: "AES-GCM", iv: nonce },
      aes_key,
      data
    );
  
    if (!returnText) {
      return decryptedData;
    }
  
    const decrypted = new Uint8Array(decryptedData);
    return new TextDecoder().decode(decrypted);
  };


--- File: src/crypto/hash.ts ---

// hash.ts
import { initializeCrypto } from './init';
import { arrayToBase64 } from '../utils';
import { HashAlgorithm, Base64String } from './types';

export const HASH = async (
  algo: HashAlgorithm, 
  data: string, 
  len?: number
): Promise<Base64String> => {
  const { crypto } = await initializeCrypto();
  const hash = await crypto.subtle.digest(algo, new TextEncoder().encode(data));
  const ary = new Uint8Array(hash);

  if (!len) {
    return arrayToBase64(ary);
  }

  const outAry = new Uint8Array(len);
  const max = Math.max(len, ary.length);

  for (let i = 0; i < max; i++) {
    outAry[i % len] = outAry[i % len] ^ ary[i % ary.length];
  }

  return arrayToBase64(outAry);
};



--- File: src/crypto/hkdf.ts ---

import { initializeCrypto } from "./init";
import { EcdhConvertKey } from "./key-conversion";
import { sleep } from "../utils";
import { base64ToArray, arrayToBase64 } from "../utils";

import type { Base64String, HKDFEncryptResult } from "./types";



export const HKDFEncrypt = async (
    b64Private: Base64String | CryptoKey,
    b64Public: Base64String | CryptoKey,
    b64data: Base64String
  ): Promise<HKDFEncryptResult> => {
    await sleep(0);
  
    const { crypto } = await initializeCrypto();
  
    // Convert keys
    const publicKey = await EcdhConvertKey(b64Public);
    const privateKey = await EcdhConvertKey(b64Private);
    
    // Generate shared secret for HKDF
    const sharedSecret = await crypto.subtle.deriveBits({ 
      name: "ECDH", 
      public: publicKey 
    }, privateKey, 256);
    
    // Convert shared-secret into a key
    const sharedSecretKey = await crypto.subtle.importKey(
      "raw", 
      sharedSecret, 
      { name: 'HKDF' }, 
      false, 
      ['deriveKey', 'deriveBits']
    );
    
    // Create SALT
    const salt = crypto.getRandomValues(new Uint8Array(16));
    
    // Convert the live-shared-secret-key into an aes key
    const derivedKey = await crypto.subtle.deriveBits({
      name: 'HKDF',
      hash: 'SHA-256',
      salt: salt,
      info: new Uint8Array([])
    }, sharedSecretKey, 256);
    
    // Convert the Key-Array to a live Key
    const aes_key = await crypto.subtle.importKey(
      "raw",
      derivedKey,
      "AES-GCM",
      false,
      ["encrypt", "decrypt"]
    );
    
    // Init Vector
    const iv = crypto.getRandomValues(new Uint8Array(16));
    
    // Encrypt
    const encrypted = await crypto.subtle.encrypt(
      { name: "AES-GCM", iv: iv },
      aes_key,
      base64ToArray(b64data)
    );
    
    return {
      ciphertext: arrayToBase64(new Uint8Array(encrypted)),
      salt: arrayToBase64(salt),
      iv: arrayToBase64(iv)
    };
  };
  
  export const HKDFDecrypt = async (
    b64Private: Base64String | CryptoKey,
    b64Public: Base64String | CryptoKey,
    b64Salt: Base64String,
    b64iv: Base64String,
    b64data: Base64String,
    returnText: boolean = false
  ): Promise<string | ArrayBuffer> => {
    await sleep(0);
  
    const { crypto } = await initializeCrypto();
  
    const publicKey = await EcdhConvertKey(b64Public);
    const privateKey = await EcdhConvertKey(b64Private);
    const salt = base64ToArray(b64Salt);
    const iv = base64ToArray(b64iv);
    const data = base64ToArray(b64data);
    
    // Generate shared secret for HKDF
    const sharedSecret = await crypto.subtle.deriveBits({ 
      name: "ECDH", 
      public: publicKey 
    }, privateKey, 256);
    
    // Convert shared-secret into a key
    const sharedSecretKey = await crypto.subtle.importKey(
      "raw",
      sharedSecret, 
      { name: 'HKDF' }, 
      false, 
      ['deriveKey', 'deriveBits']
    );
    
    // Convert the live-shared-secret-key into an aes key
    const derivedKey = await crypto.subtle.deriveBits({
      name: 'HKDF',
      hash: 'SHA-256',
      salt: salt,
      info: new Uint8Array([])
    }, sharedSecretKey, 256);
  
    // Convert the Key-Array to a live Key
    const aes_key = await crypto.subtle.importKey(
      "raw",
      derivedKey,
      "AES-GCM",
      false,
      ["encrypt", "decrypt"]
    );
  
    try {
      const aes_data = await crypto.subtle.decrypt(
        { name: "AES-GCM", iv: iv },
        aes_key,
        data
      );
  
      if (!returnText) {
        return aes_data;
      }
  
      const decrypted = new Uint8Array(aes_data);
      return new TextDecoder().decode(decrypted);
    } catch (e:any) {
      console.log({name: e.name, stack: e.stack, message: e.message});
      throw e;
    }
  };


--- File: src/crypto/hmac.ts ---

// hmac.ts
import { initializeCrypto } from './init';
import { HexString } from './types';

export const HMAC = async (secret: string, data: string): Promise<HexString> => {
  const { crypto } = await initializeCrypto();
  const encoder = new TextEncoder();
  const encodedSecret = encoder.encode(secret);
  const encodedData = encoder.encode(data);

  const key = await crypto.subtle.importKey(
    "raw",
    encodedSecret,
    { name: "HMAC", hash: { name: "SHA-256" } },
    false,
    ["sign", "verify"]
  );

  const sig = await crypto.subtle.sign("HMAC", key, encodedData);
  const b = new Uint8Array(sig);
  
  return Array.prototype.map
    .call(b, (x: number) => ("00" + x.toString(16)).slice(-2))
    .join("");
};


--- File: src/crypto/init.ts ---

import type { CryptoContext } from './types';
export const initializeCrypto = async (): Promise<CryptoContext> => {
    let cryptoAPI: CryptoContext;
    
    if (typeof globalThis.crypto !== 'undefined') {
      cryptoAPI = {
        crypto: globalThis.crypto,
        CryptoKey: globalThis.CryptoKey || null
      };
    } else if (typeof globalThis.require === 'function') {
      const { webcrypto } = await import('crypto');
      cryptoAPI = {
        crypto: webcrypto as Crypto,
        CryptoKey: null
      };
    } else {
      throw new Error('Crypto API is not available in this environment');
    }
    
    return cryptoAPI;
  };
  




--- File: src/crypto/key-conversion.ts ---

import type { Base64String } from "./types";
import { sleep } from "../utils";
import { initializeCrypto } from "./init";
import { base64ToArray } from "../utils";


// key-conversion.ts
export const EcdhConvertKey = async (
    unknown_key: Base64String | CryptoKey
  ): Promise<CryptoKey> => {
    await sleep(0);
  
    const { crypto, CryptoKey } = await initializeCrypto();
    
    // Type guard for CryptoKey
    if (CryptoKey && unknown_key instanceof CryptoKey) {
      return unknown_key;
    }
  
    if (typeof unknown_key !== 'string') {
      throw new Error("Invalid key format");
    }
  
    try {
      // Try SPKI PUBLIC
      return await crypto.subtle.importKey(
        "spki",
        base64ToArray(unknown_key),
        { name: "ECDH", namedCurve: "P-256" },
        true,
        []
      );
    } catch (e) {}
  
    try {
      // Try RAW PUBLIC
      return await crypto.subtle.importKey(
        "raw",
        base64ToArray(unknown_key),
        { name: "ECDH", namedCurve: "P-256" },
        true,
        []
      );
    } catch (e) {}
  
    try {
      // Try PKCS8 PRIVATE
      return await crypto.subtle.importKey(
        "pkcs8",
        base64ToArray(unknown_key),
        { name: "ECDH", namedCurve: "P-256" },
        false,
        ["deriveKey", "deriveBits"]
      );
    } catch (e) {}
  
    try {
      // Try RAW PUBLIC - PERVERTED
      const longKey = new Uint8Array([4, ...Array.from(base64ToArray(unknown_key))]);
      return await crypto.subtle.importKey(
        "raw",
        longKey,
        { name: "ECDH", namedCurve: "P-256" },
        true,
        []
      );
    } catch (e) {
      throw new Error("UNRECOGNIZED KEY FORMAT");
    }
  };
  
  export const EcdsaConvertKey = async (
    unknown_key: Base64String | CryptoKey
  ): Promise<CryptoKey> => {
    await sleep(0);
  
    const { crypto, CryptoKey } = await initializeCrypto();
    
    // Type guard for CryptoKey
    if (CryptoKey && unknown_key instanceof CryptoKey) {
      return unknown_key;
    }
  
    if (typeof unknown_key !== 'string') {
      throw new Error("Invalid key format");
    }
  
    try {
      // Try SPKI PUBLIC
      return await crypto.subtle.importKey(
        "spki",
        base64ToArray(unknown_key),
        { name: "ECDSA", namedCurve: "P-256" },
        true,
        ["verify"]
      );
    } catch (e) {}
  
    try {
      // Try RAW PUBLIC
      return await crypto.subtle.importKey(
        "raw",
        base64ToArray(unknown_key),
        { name: "ECDSA", namedCurve: "P-256" },
        true,
        ["verify"]
      );
    } catch (e) {}
  
    try {
      // Try PKCS8 PRIVATE
      return await crypto.subtle.importKey(
        "pkcs8",
        base64ToArray(unknown_key),
        { name: "ECDSA", namedCurve: "P-256" },
        false,
        ["sign"]
      );
    } catch (e) {}
  
    try {
      // Try RAW PUBLIC - PERVERTED
      const longKey = new Uint8Array([4, ...Array.from(base64ToArray(unknown_key))]);
      return await crypto.subtle.importKey(
        "raw",
        longKey,
        { name: "ECDSA", namedCurve: "P-256" },
        true,
        ["sign"]
      );
    } catch (e) {
      throw new Error("UNRECOGNIZED KEY FORMAT");
    }
  };


--- File: src/crypto/password.ts ---

import type { Base64String } from "./types";
import { AESMakeKey, AESDecrypt, AESEncrypt, AESImportKey } from "./aes";
import { HASH } from "./hash";
import { sleep } from "../utils";

// password.ts
export const PASSWORD_ENCRYPT = async (
    password: string,
    base64data: Base64String
  ): Promise<Base64String> => {
    await sleep(0);
  
    let hashedPassword = password;
    
    for (let i = 0; i < 10; i++) {
      hashedPassword = await HASH("SHA-512", hashedPassword);
    }
    
    const passwordHash = btoa(hashedPassword);
    const aes = await AESMakeKey(true) as Base64String;
    const output = await AESEncrypt(aes, base64data, passwordHash);
  
    return btoa(JSON.stringify({
      ciphertext: output.ciphertext,
      aes
    }));
  };
  
  export const PASSWORD_DECRYPT = async (
    password: string,
    base64data: Base64String
  ): Promise<string> => {
    await sleep(0);
  
    let hashedPassword = password;
    
    for (let i = 0; i < 10; i++) {
      hashedPassword = await HASH("SHA-512", hashedPassword);
    }
    
    const passwordHash = btoa(hashedPassword);
    const encryptedDataObject = JSON.parse(atob(base64data));
    const aes = await AESImportKey(encryptedDataObject.aes, false);
    const plaintext = await AESDecrypt(
      aes,
      passwordHash,
      encryptedDataObject.ciphertext,
      true
    ) as string;
  
    return plaintext;
  };


--- File: src/crypto/types.ts ---

// types.ts
export type Base64String = string;
export type HexString = string;

export interface CryptoContext {
  crypto: Crypto;
  CryptoKey: typeof CryptoKey | null;
}

export interface AESEncryptResult {
  ciphertext: Base64String;
  iv: Base64String;
}

// Additional types needed for AES operations
export interface AESDecryptResult {
  data: ArrayBuffer;
  text?: string;
}

export interface PasswordEncryptResult {
  ciphertext: Base64String;
  aes: Base64String;
}

export interface ECKeyPairExportable {
  publicKey: Base64String;
  privateKey: Base64String;
  jwkPublicKey: JsonWebKey;
  jwkPrivateKey: JsonWebKey;
  rawPublicKey: Base64String;
  rawPublicKeyLite: Base64String;
}

export interface ECKeyPairNonExportable {
  publicKey: Base64String;
  privateKey: CryptoKey;
  rawPublicKey: Base64String;
  rawPublicKeyLite: Base64String;
}

export type ECKeyPair = ECKeyPairExportable | ECKeyPairNonExportable;

export type HashAlgorithm = 'SHA-1' | 'SHA-256' | 'SHA-384' | 'SHA-512';

export interface HKDFEncryptResult {
  ciphertext: Base64String;
  salt: Base64String;
  iv: Base64String;
}

export interface ECSignatureKeyPair {
  publicKey: Base64String;
  privateKey: Base64String | CryptoKey;
}


--- File: src/index.ts ---

export * from './crypto/types';
export * from './utils';
export * from './crypto/hmac';
export * from './crypto/hash';
export * from './crypto/aes';
export * from './crypto/password';
export * from './crypto/ec';
export * from './crypto/hkdf';
export * from './crypto/ec-signature';
export * from './crypto/key-conversion';


--- File: src/types/crypto/index.d.ts ---

// src/types/crypto/index.d.ts
declare module '@/types/crypto' {
    export type Base64String = string;
    export type HexString = string;
    
    export interface CryptoContext {
      crypto: Crypto;
      CryptoKey: typeof CryptoKey | null;
    }
  
    export interface AESEncryptResult {
      ciphertext: Base64String;
      iv: Base64String;
    }
  
    export interface PasswordEncryptResult {
      ciphertext: Base64String;
      aes: Base64String;
    }
  
    export interface ECKeyPairExportable {
      publicKey: Base64String;
      privateKey: Base64String;
      jwkPublicKey: JsonWebKey;
      jwkPrivateKey: JsonWebKey;
      rawPublicKey: Base64String;
      rawPublicKeyLite: Base64String;
    }
  
    export interface ECKeyPairNonExportable {
      publicKey: Base64String;
      privateKey: CryptoKey;
      rawPublicKey: Base64String;
      rawPublicKeyLite: Base64String;
    }
  
    export type ECKeyPair = ECKeyPairExportable | ECKeyPairNonExportable;
    
    export type HashAlgorithm = 'SHA-1' | 'SHA-256' | 'SHA-384' | 'SHA-512';
  }


--- File: src/types/index.d.ts ---




--- File: src/utils/index.ts ---

import type { Base64String } from "@/types/crypto";
export const base64ToArray = (strng: Base64String): Uint8Array => {
    return Uint8Array.from(atob(strng), (c) => c.charCodeAt(0));
  };
  
  export const arrayToBase64 = (utf8Bytes: Uint8Array): Base64String => {
    const chunkSize = 8192;
    const chunks: string[] = [];
    
    for (let i = 0; i < utf8Bytes.length; i += chunkSize) {
      const chunk = utf8Bytes.subarray(i, i + chunkSize);
      chunks.push(String.fromCharCode.apply(null, [...chunk]));
    }
    
    return btoa(chunks.join(''));
  };


  export const sleep = async (duration: number): Promise<void> => {
    await new Promise(resolve => setTimeout(resolve, duration));
  };


--- File: tests/crypto-operations.test.ts ---

import { 
    HASH,
    HMAC,
    AESMakeKey,
    AESEncrypt,
    AESDecrypt,
    PASSWORD_ENCRYPT,
    PASSWORD_DECRYPT,
    EcMakeCryptKeys,
    EcEncrypt,
    EcDecrypt,
    HKDFEncrypt,
    HKDFDecrypt,
    EcMakeSigKeys,
    EcSignData,
    EcVerifySig
  } from '../src';

  import { describe, expect, test } from '@jest/globals';
  
  describe('Cryptographic Operations', () => {
    describe('Basic Operations', () => {
      test('HASH should generate consistent SHA-256 hashes', async () => {
        const testData = 'test data';
        const hash1 = await HASH('SHA-256', testData);
        const hash2 = await HASH('SHA-256', testData);
        expect(hash1).toBe(hash2);
      });
  
      test('HMAC should generate valid signatures', async () => {
        const secret = 'secret key';
        const data = 'test data';
        const signature = await HMAC(secret, data);
        expect(signature).toBeTruthy();
        expect(typeof signature).toBe('string');
      });
    });
  
    describe('AES Operations', () => {
      test('AES encryption/decryption cycle should work', async () => {
        const testData = btoa('test data');
        const key = await AESMakeKey(true);
        const encrypted = await AESEncrypt(key, testData);
        
        expect(encrypted.ciphertext).toBeTruthy();
        expect(encrypted.iv).toBeTruthy();
        
        const decrypted = await AESDecrypt(key, encrypted.iv, encrypted.ciphertext, true);
        expect(decrypted).toBe('test data');
      });
    });
  
    describe('Password Operations', () => {
      test('Password encryption/decryption cycle should work', async () => {
        const password = 'testPassword123';
        const testData = btoa('sensitive data');
        
        const encrypted = await PASSWORD_ENCRYPT(password, testData);
        const decrypted = await PASSWORD_DECRYPT(password, encrypted);
        
        expect(decrypted).toBe('sensitive data');
      });
    });
  
    describe('Elliptic Curve Operations', () => {
      test('EC key generation and encryption cycle should work', async () => {
        const keys = await EcMakeCryptKeys(true);
        expect(keys.publicKey).toBeTruthy();
        expect(keys.privateKey).toBeTruthy();
  
        const testData = btoa('test data');
        const encrypted = await EcEncrypt(keys.privateKey, keys.publicKey, testData);
        
        expect(encrypted.ciphertext).toBeTruthy();
        expect(encrypted.iv).toBeTruthy();
        
        const decrypted = await EcDecrypt(
          keys.privateKey,
          keys.publicKey,
          encrypted.iv,
          encrypted.ciphertext,
          true
        );
        expect(decrypted).toBe('test data');
      });
  
      test('HKDF encryption/decryption cycle should work', async () => {
        const keys = await EcMakeCryptKeys(true);
        const testData = btoa('test data');
        
        const encrypted = await HKDFEncrypt(keys.privateKey, keys.publicKey, testData);
        expect(encrypted.ciphertext).toBeTruthy();
        expect(encrypted.salt).toBeTruthy();
        expect(encrypted.iv).toBeTruthy();
        
        const decrypted = await HKDFDecrypt(
          keys.privateKey,
          keys.publicKey,
          encrypted.salt,
          encrypted.iv,
          encrypted.ciphertext,
          true
        );
        expect(decrypted).toBe('test data');
      });
    });
  
    describe('Digital Signatures', () => {
      test('EC signature operations should work', async () => {
        const keys = await EcMakeSigKeys(true);
        const testData = btoa('test data');
        
        const signature = await EcSignData(keys.privateKey, testData);
        expect(signature).toBeTruthy();
        
        const isValid = await EcVerifySig(keys.publicKey, signature, testData);
        expect(isValid).toBe(true);
      });
    });
  
    describe('Error Cases', () => {
      test('Should handle invalid keys appropriately', async () => {
        const invalidKey = 'invalid-key';
        const testData = btoa('test data');
        
        await expect(AESEncrypt(invalidKey, testData))
          .rejects
          .toThrow();
      });
  
      test('Should handle invalid data in password operations', async () => {
        const password = 'testPassword123';
        const invalidData = 'not-base64-encoded';
        
        await expect(PASSWORD_ENCRYPT(password, invalidData))
          .rejects
          .toThrow();
      });
    });
  });


--- File: tsconfig.json ---
(Skipped (non-matching extension))
